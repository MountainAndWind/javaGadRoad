package dataStructure.Queue;

/**
 * @description:队列跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，
 * 用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。
 * 链表实现较为简单
 * 循环链表解决空间浪费的问题
 * 判空：head == tail  ，  判满：(tail+1)%n=head  tail 指向的位置实际上是没有存储数据的，循环队列会浪费一个数组的存储空间。
 *
 * 阻塞队列：其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，
 *     直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。
 *     你应该已经发现了，上述的定义就是一个“生产者 - 消费者模型”！是的，我们可以使用阻塞队列，轻松实现一个“生产者 - 消费者模型”！
 *     基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。
 *
 * 并发队列:线程安全的队列我们叫作并发队列  最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。
 *     实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。
 *
 *
 * 线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？
 *     两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；
 *     另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理
 *     基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，
 *         请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。
 *     而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。
 *         不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能
 * @author: slfang
 * @time: 2020/7/1 17:37
 */
public class Dome1 {

    public static void main(String[] args) {
        System.out.println();
    }

}
